# Scelte progettuali progetto asm.

1. Per prima cosa si è scelto di utilizzare un sistema che sfruttasse in modo pesante le variabili globali, questo perché utilizzandole in un progetto di così ridotte dimensioni si è aumentata notevolmente la leggibilità del codice e nel contempo si è ridotta la complessità. Da sottolineare che se il progetto fosse stato di maggiore livello questo approccio non si sarebbe potuto utilizzare poiché sarebbero state compromesse le prestazioni totali del progetto compromettendone il corretto funzionamento in caso di un applicazione pratica.
2. Divisione in funzioni ridotta: Si è scelto di dividere il progetto in relativamente poche funzioni e di tenere tutti i controlli su input output in un unica funzione chiamata check. Sarebbe stato possibile utilizzare tranquillamente una divisione maggiore in funzioni minori, per esempio un check_rpm, check_init, etc. Ma al contrario è stato ritenuto più pratico e decisamente più leggibile mantenere il codice in un unico file. Oltre a leggibilità e praticità un altro vantaggio di questa divisione è la mantenibilità infatti la divisione in funzioni risulta logica ed immediata per un programmatore che dovesse trovarsi a modificare il codice senza che si debba eccessivamente saltare da un file ad un altro.
3. File .inc: Nonostante il linguaggio asm sia fortemente legato alla macchina sottostante, si è deciso, di utilizzare un "trucchetto" per permetterne, per quanto possibile, lo spostamento agevole su un altra piattaforma. Infatti sarà sufficiente cambiare i codici delle sys call nel file syscall.inc per chiamare le syscall di un altro sistema. Da far notare che questo trucco può essere usato solo su sistemi unix like poiché i parametri delle funzioni sono sempre gli stessi (probabilmente basati sullo standard posix ma da controllare prima di scriverlo).
4. Buffer di 9 byte con lettura di una riga alla volta: è stato scelto di utilizzare un buffer di 9 byte (lunghezza di una riga) leggendo ad ogni iterazione del programma una riga. Questa scelta è molto importante perché sfora un po' dalle consegne. Infatti la consegna prevedeva di utilizzare file di non più di 100 righe di lunghezza massima. sfruttando tale informazione si sarebbe potuta generare un codice semplicistico che leggesse in un buffer l'intero file. Questo metodo però era sembrato eccessivamente semplicistico. Un altra via prendibile era quella di leggere un byte alla volta del file di input, ma questa avrebbe richiesto un numero spropositato di chiamate al kernel cosa che avrebbe veramente compromesso le prestazioni totali del programma. Quindi l'unica altra scelta possibile è stata quella di leggere una riga per volta il file generando un buffer molto leggero 9 byte ma comodo, innanzi tutto questo metodo può essere utilizzato con file di dimensione decisamente arbitraria, mentre il primo non avrebbe funzionato con un file di dimensione superire a 100 righe (900b), in secondo luogo questo metodo risulta a nostro avviso il metodo ottimale poiché stabilisce un compromesso tra chiamata a syscall e flessibilità del codice. Oltre a questo si sarebbe potuto utilizzare un 3 metodo, quello di mappare in memoria il file ed accedervi come in un array, ma questo sforava dalle nozioni fornite dal corso.
